# Walkthrough – Creating links

[Back to Challenge](../09_creating_links.md)

In this walkthrough, I'll show you how I'd:

- Create a User Story from the requirement
- Write a feature test for the User Story
- Solve the feature test by following a TDD cycle.
- Refactor the solution into the Link model.
- Test in the development environment.

> If you prefer to work directly with a code diff, [here's](https://github.com/sjmog/bookmark_manager/commit/a1ec7cbb910b5a7df2be59ba292c161bd7e5fe8e) a commit for this stage.

## Creating the User Story

The requirement is:

* Add new links :construction:

A User Story for this could be:

```
As a user
So I can store bookmark data for later retrieval
I want to add a link to Bookmark Manager
```

> Yours can be different to this. User Stories are a thinking tool, not a 'right/wrong' sort of thing.

## Write a feature test for adding links

Let's add a feature test for the user:

- Visiting a page, `/links/new`
- Typing a URL into a form on that page
- Submitting the form
- Seeing the link they just submitted.

> I find it helpful to think out the user's actions in a bullet-point list like the one above, before writing my Capybara test.

In Capybara-speak, these actions look like this:

```ruby
feature 'Adding a new link' do
  scenario 'A user can add a link to Bookmark Manager' do
    visit('/add-a-new-link')
    fill_in('url', with: 'http://testlink.com')
    click_button('Submit')

    expect(page).to have_content 'http://testlink.com'
  end
end
```

## Solving the feature test

**I run my test.** It fails:

```
Failures:

  1) Adding a new link A user can add a link to Bookmark Manager
     Failure/Error: fill_in('url', with: 'http://testlink.com')
     
     Capybara::ElementNotFound:
       Unable to find visible field "url" that is not disabled
```

We need to create a Sinatra route in `app.rb`:

```ruby
# in app.rb

get '/add-a-new-link' do
  erb :add_a_new_link
end
```

> Dislike this route structure? Think `add-a-new-link` is a crummy name for a route? I do too! We'll fix it later, to make it RESTful.

**I run my test.** I have a new error: there's nothing to 'fill in' on the page. So, I'll add a form to the `views/links/new.erb` file:

```html
<!-- inside views/links/new.erb -->

<form>
  <input type="text" name="url" />
</form>
```

> I've given the `<input>` tag a `name` attribute of `url`. Right now, this is so Capybara knows how to find it.

**I run my test.** Now I have a new failure: 

```
Failures:

  1) Adding a new link A user can add a link to Bookmark Manager
     Failure/Error: click_button('Submit')
     
     Capybara::ElementNotFound:
       Unable to find visible button "Submit"
```

I have no 'Submit' button. Easily solvable:

```html
<!-- inside views/links/new.erb -->

<form>
  <input type="text" name="url" />
  <input type="submit" value="Submit" />
</form>
```

**I run my test.** It fails:

```
Failures:

  1) Adding a new link A user can add a link to Bookmark Manager
     Failure/Error: expect(page).to have_content 'http://testlink.com'
       expected to find text "http://testlink.com" in ""
```

It looks like my link isn't showing up on the page. Here's what's happening at the moment:

- The user visits the `/add-a-new-link` route and `GET`s an HTML page containing a form from the Sinatra application.
- The user fills out the form and submits.
- Submitting a form defaults to sending a `GET` request to the current URL: `/add-a-new-link`. 

In other words: right now, submitting the form just fetches a new form from the Sinatra application.

We need to the form data to submit to a different route in Sinatra. In that route, we'll try to save the form data to the database in some way.

We should use a `POST` route to define this route, as we're submitting data to the application to be saved.

Let's update the form:

```html
<form action="/create-new-link" method="post">
  <input type="text" name="url" />
  <input type="submit" value="Submit" />
</form>
```

**I run my test.** As expected, the form submits to a non-existent Sinatra route: 

```
Failures:

  1) Adding a new link A user can add a link to Bookmark Manager
     Failure/Error: expect(page).to have_content 'http://testlink.com'
       expected to find text "http://testlink.com" in "Sinatra doesn’t know this ditty. Try this: # in app.rb class BookmarkManager post '/create-new-link' do \"Hello World\" end end"
```

Let's define this `POST` route, and print to the console whenever the route is activated:

```ruby
# in app.rb

get '/add-a-new-link' do
  erb :add_a_new_link
end

post '/create-new-link' do
  p "Form data submitted to the /links route!"
end
```

**I run my test.** In my logs, I can see that the form submits to the `/links` route:

![A screenshot of the Terminal, showing form data was submitted to the post request](../images/form-data-submitted.png)

We can now flesh out the route, saving the submitted data to the database:

```ruby
# in app.rb

get '/add-a-new-link' do
  erb :add_a_new_link
end

post '/create-new-link' do
  url = params['url']
  connection = PG.connect(dbname: 'bookmark_manager_test')
  connection.exec("INSERT INTO links (url) VALUES('#{url}')")
  redirect '/'
end
```

Take the time to understand the code above. In it, we:

- Get the `url` from the submitted form data (`params`).
- Connect to the test database.
- Execute the SQL to insert a new link to the database, with a url value of the url submitted by the user.
- Redirect to the homepage (which shows all links, thanks to the `get '/'` route defined in `app.rb`).

**I run my test.** It passes.

> I really do run my tests this much!

## Refactoring

At the moment, our `POST` route connects to the database and executes SQL: all in the controller. **This is directly against the idea of MVC.** If we leave it, it'll give future developers licence to write weird, confusing code. Any database interaction should happen in the model.

Just like we did with `.all`, let's imagine a better interface for the `POST` action of our controller. How about:

```ruby
post '/create-new-link' do
  Link.create(url: params['url'])
  redirect '/'
end
```

This interface is attractive. Let's write a unit test for it:

```ruby
# in spec/link_spec.rb

describe '.create' do
  it 'creates a new link' do
    Link.create(url: 'http://www.testlink.com')

    expect(Link.all).to include 'http://www.testlink.com'
  end
end
```

Let's solve our failing unit test by moving logic from the controller into the model:

```ruby
# in lib/link.rb

def self.create(options)
  connection = PG.connect(dbname: 'bookmark_manager_test')
  connection.exec("INSERT INTO links (url) VALUES('#{options[:url]}')")
end
```

This passes our unit test. We can now use the nicer interface in the controller:

```ruby
post '/create-new-link' do
  Link.create(url: params['url'])
  redirect '/'
end
```

Our `rspec` tests all pass.

## Testing in the development environment

It's always a good idea to double-check that a feature which works in the test environment also works in the development environment.

In this case, it doesn't! That's because our `Link.create` method connects to the `bookmark_manager_test` database by default. We need to use the same conditional connection that we did in the `Link.all` method:

```ruby
def self.create(options)
  if ENV['ENVIRONMENT'] == 'test'
    connection = PG.connect(dbname: 'bookmark_manager_test')
  else
    connection = PG.connect(dbname: 'bookmark_manager')
  end

  connection.exec("INSERT INTO links (url) VALUES('#{options[:url]}')")
end
```

## (Very optional!) Testing that the `Link` model connects to the right database

We had no failing test to tell us our code wasn't working in development. This is a problem: one purpose of tests is to stop broken features from existing!

Whenever this 'vacuous testing' happens, we should **come up with a test to stop it from happening.** In this case, let's add some tests to our `link_spec.rb` unit tests.

We're going to: 

1. Move the database connection logic to a different method on `Link`. Let's call it `Link.connection`, 
2. Substitute the connection logic in `Link.all` and `Link.create` for the return value of `Link.connection`,
3. Test that `Link.connection` connects to the test database when testing, and
4. Test that `Link.connection` connects to the development database when not testing.

### 1. Moving the database connection logic to `Link.connection`

Here's the `Link` class after extracting the connection logic to its own class method:

```ruby
# in lib/link.rb

require 'pg'

class Link
  def self.connection
    if ENV['ENVIRONMENT'] == 'test'
      return PG.connect(dbname: 'bookmark_manager_test')
    else
      return PG.connect(dbname: 'bookmark_manager')
    end
  end

  ### rest of the class ###
end
```

### 2. Substituting the connection logic in `.all` and `.create`

Here's the `Link` class after extracting the connection logic:

```ruby
# in lib/link.rb

require 'pg'

class Link
  def self.connection
    if ENV['ENVIRONMENT'] == 'test'
      return PG.connect(dbname: 'bookmark_manager_test')
    else
      return PG.connect(dbname: 'bookmark_manager')
    end
  end

  # We can now use the .connection method in .all and .create
  def self.all
    result = connection.exec("SELECT * FROM links")
    result.map { |link| link['url'] }
  end

  def self.create(options)
    connection.exec("INSERT INTO links (url) VALUES('#{options[:url]}')")
  end
end
```

### 3. Test that `Link.connection` connects to the test database in the test environment

We can now test the `Link.connection` method on its own:

```ruby
# in spec/link_spec.rb

describe '.connection' do
  it 'connects to the test database when testing' do
    expect(PG).to receive(:connect).with(dbname: 'bookmark_manager_test')

    Link.connection
  end
end
```

Our test is simple: we expect `pg` to be asked to connect to the `bookmark_manager_test` database.

### 4. Test that `Link.connection` connects to the development database in the development environment

Let's test that, when in the development environment, `Link.connection` connects to the development database. We'll have to temporarily set the `ENV` during our test.

```ruby
# in spec/link_spec.rb

describe '.connection' do
  it 'connects to the development database otherwise' do
    # Set the environment to 'development'
    ENV['ENVIRONMENT'] = 'development'

    expect(PG).to receive(:connect).with(dbname: 'bookmark_manager')
    Link.connection
    
    # Don't forget to set the environment back at the end!
    ENV['ENVIRONMENT'] = 'test'
  end
end
```

With all tests passing, we can now be certain that our `Link` model is connecting to the right database in both the development and test environments.

[Next Challenge](../10_using_an_orm.md)
