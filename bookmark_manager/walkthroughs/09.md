# Walkthrough – Creating links

[Back to Challenge](../09_creating_links.md)

In this walkthrough, I'll show you how I'd:

- Create a User Story from the requirement
- Write a feature test for the User Story
- Solve the feature test by following a TDD cycle.
- Refactor the solution into the Link model.
- Test in the development environment.

> If you prefer to work directly with a code diff, [here's](https://github.com/sjmog/bookmark_manager/commit/251a4902e45b47b3c29ed9e9db41d393b545a5d2) a commit for this stage.

## Creating the User Story

The requirement is:

* Add new links :construction:

A User Story for this could be:

```
As a user
So I can store bookmark data for later retrieval
I want to add a link to Bookmark Manager
```

> Yours can be different to this. User Stories are a thinking tool, not a 'right/wrong' sort of thing.

## Write a feature test for adding links

Let's add a feature test for the user:

- Visiting a page, `/links/new`
- Typing a URL into a form on that page
- Submitting the form
- Seeing the link they just submitted.

> I find it helpful to think out the user's actions in a bullet-point list like the one above, before writing my Capybara test.

In Capybara-speak, these actions look like this:

```ruby
feature 'Adding a new link' do
  scenario 'A user can add a link to Bookmark Manager' do
    visit('/add-a-new-link')
    fill_in('url', with: 'http://testlink.com')
    click_button('Submit')

    expect(page).to have_content 'http://testlink.com'
  end
end
```

## Solving the feature test

**I run my test.** It fails:

```
Failures:

  1) Adding a new link A user can add a link to Bookmark Manager
     Failure/Error: fill_in('url', with: 'http://testlink.com')
     
     Capybara::ElementNotFound:
       Unable to find visible field "url" that is not disabled
```

We need to create a Sinatra route in `app.rb`:

```ruby
# in app.rb

get '/add-a-new-link' do
  erb :add_a_new_link
end
```

> Dislike this route structure? Think `add-a-new-link` is a crummy name for a route? I do too! We'll fix it later, to make it RESTful.

**I run my test.** I have a new error: there's nothing to 'fill in' on the page. So, I'll add a form to the `views/links/new.erb` file:

```html
<!-- inside views/links/new.erb -->

<form>
  <input type="text" name="url" />
</form>
```

> I've given the `<input>` tag a `name` attribute of `url`. Right now, this is so Capybara knows how to find it.

**I run my test.** Now I have a new failure: 

```
Failures:

  1) Adding a new link A user can add a link to Bookmark Manager
     Failure/Error: click_button('Submit')
     
     Capybara::ElementNotFound:
       Unable to find visible button "Submit"
```

I have no 'Submit' button. Easily solvable:

```html
<!-- inside views/links/new.erb -->

<form>
  <input type="text" name="url" />
  <input type="submit" value="Submit" />
</form>
```

**I run my test.** It fails:

```
Failures:

  1) Adding a new link A user can add a link to Bookmark Manager
     Failure/Error: expect(page).to have_content 'http://testlink.com'
       expected to find text "http://testlink.com" in ""
```

It looks like my link isn't showing up on the page. Here's what's happening at the moment:

- The user visits the `/add-a-new-link` route and `GET`s an HTML page containing a form from the Sinatra application.
- The user fills out the form and submits.
- Submitting a form defaults to sending a `GET` request to the current URL: `/add-a-new-link`. 

In other words: right now, submitting the form just fetches a new form from the Sinatra application.

We need to the form data to submit to a different route in Sinatra. In that route, we'll try to save the form data to the database in some way.

We should use a `POST` route to define this route, as we're submitting data to the application to be saved.

Let's update the form:

```html
<form action="/create-new-link" method="post">
  <input type="text" name="url" />
  <input type="submit" value="Submit" />
</form>
```

**I run my test.** As expected, the form submits to a non-existent Sinatra route: 

```
Failures:

  1) Adding a new link A user can add a link to Bookmark Manager
     Failure/Error: expect(page).to have_content 'http://testlink.com'
       expected to find text "http://testlink.com" in "Sinatra doesn’t know this ditty. Try this: # in app.rb class BookmarkManager post '/create-new-link' do \"Hello World\" end end"
```

Let's define this `POST` route, and print to the console whenever the route is activated:

```ruby
# in app.rb

get '/add-a-new-link' do
  erb :add_a_new_link
end

post '/create-new-link' do
  p "Form data submitted to the /links route!"
end
```

**I run my test.** In my logs, I can see that the form submits to the `/links` route:

![A screenshot of the Terminal, showing form data was submitted to the post request](../images/form-data-submitted.png)

We can now flesh out the route, saving the submitted data to the database:

```ruby
# in app.rb

get '/add-a-new-link' do
  erb :add_a_new_link
end

post '/create-new-link' do
  url = params['url']
  connection = PG.connect(dbname: 'bookmark_manager_test')
  connection.exec("INSERT INTO links (url) VALUES('#{url}')")
  redirect '/'
end
```

Take the time to understand the code above. In it, we:

- Get the `url` from the submitted form data (`params`).
- Connect to the test database.
- Execute the SQL to insert a new link to the database, with a url value of the url submitted by the user.
- Redirect to the homepage (which shows all links, thanks to the `get '/'` route defined in `app.rb`).

**I run my test.** It passes.

> I really do run my tests this much!

## Refactoring

At the moment, our `POST` route connects to the database and executes SQL: all in the controller. **This is directly against the idea of MVC.** If we leave it, it'll give future developers licence to write weird, confusing code. Any database interaction should happen in the model.

Just like we did with `.all`, let's imagine a better interface for the `POST` action of our controller. How about:

```ruby
post '/create-new-link' do
  Link.create(url: params['url'])
  redirect '/'
end
```

This interface is attractive. Let's write a unit test for it:

```ruby
# in spec/link_spec.rb

describe '.create' do
  it 'creates a new link' do
    Link.create(url: 'http://www.testlink.com')

    expect(Link.all).to include 'http://www.testlink.com'
  end
end
```

Let's solve our failing unit test by moving logic from the controller into the model:

```ruby
# in lib/link.rb

def self.create(options)
  connection = PG.connect(dbname: 'bookmark_manager_test')
  connection.exec("INSERT INTO links (url) VALUES('#{options[:url]}')")
end
```

This passes our unit test. We can now use the nicer interface in the controller:

```ruby
post '/create-new-link' do
  Link.create(url: params['url'])
  redirect '/'
end
```

Our `rspec` tests all pass.

## Testing in the development environment

It's always a good idea to double-check that a feature which works in the test environment also works in the development environment.

In this case, it doesn't! That's because our `Link.create` method connects to the `bookmark_manager_test` database by default. We need to use the same conditional connection that we did in the `Link.all` method:

```ruby
def self.create(options)
  if ENV['ENVIRONMENT'] == 'test'
    connection = PG.connect(dbname: 'bookmark_manager_test')
  else
    connection = PG.connect(dbname: 'bookmark_manager')
  end

  connection.exec("INSERT INTO links (url) VALUES('#{options[:url]}')")
end
```

[Next Challenge](../10_extracting_a_database_setup_object.md)
