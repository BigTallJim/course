# Walkthrough – Wrapping Database Data in Program Objects

[Back to Challenge](../10_wrapping_database_data_in_program_objects.md)

Wouldn't it be great if our view could do this?

```html
# in views/bookmarks/index.erb

<ul>
  <% @bookmarks.each do |bookmark| %>
    <li>
      <a href="<%= bookmark.url %>">
        <%= bookmark.title %>
      </a>
    </li>
  <% end %>
</ul>
```

To do this, we need to make sure that each `bookmark` is an object that responds to `url` and `title`. At the moment, each `bookmark` is a string.

Confused? Let's use the domain model to reason about it. Here's what we're doing right now:

```
╔════════════╗         .all         ╔════════════╗  SELECT * FROM bookmarks; ╔════════════╗
║            ║--------------------->║            ║-------------------------->║            ║
║ Controller ║  [array of strings]  ║  Bookmark  ║      {result object}      ║  Database  ║
║            ║<---------------------║            ║<--------------------------║            ║
╚════════════╝                      ╚════════════╝                           ╚════════════╝
```

Here's what we should be doing:

```
╔════════════╗         .all         ╔════════════╗  SELECT * FROM bookmarks; ╔════════════╗
║            ║--------------------->║            ║-------------------------->║            ║
║ Controller ║ [array of bookmarks] ║  Bookmark  ║      {result object}      ║  Database  ║
║            ║<---------------------║            ║<--------------------------║            ║
╚════════════╝                      ╚════════════╝                           ╚════════════╝
```

So, we need to:

- Get the result object from the database
- Wrap it in a `Bookmark` instance
- Make sure that `Bookmark` instance responds to `id` and `url`.

### Wrapping returned data

We start by updating the test for `Bookmark.all`:

```diff
   # in spec/bookmark_spec.rb

   describe '.all' do
     it 'returns all bookmarks in an array' do
       # Add the test data
-      Bookmark.create(url: "http://makersacademy.com")
-      Bookmark.create(url: "http://destroyallsoftware.com")
-      Bookmark.create(url: "http://google.com")
+      bookmark_1 = Bookmark.create(url: "http://makersacademy.com")
+      bookmark_2 = Bookmark.create(url: "http://destroyallsoftware.com")
+      bookmark_3 = Bookmark.create(url: "http://google.com")

       expected_bookmarks = [
-        'http://makersacademy.com',
-        'http://destroyallsoftware.com',
-        'http://google.com'
+        bookmark_1,
+        bookmark_2,
+        bookmark_3
       ]

       expect(Bookmark.all).to eq expected_bookmarks
      end
    end
```

And the test for `Bookmark.create`:

```diff
   describe '.create' do
     it 'creates a new bookmark' do
-      Bookmark.create(url: 'http://www.testbookmark.com')
+      bookmark = Bookmark.create(url: 'http://www.testbookmark.com')

-      expect(Bookmark.all).to include 'http://www.testbookmark.com'
+      expect(Bookmark.all).to include bookmark
     end
   end
```

Now let's update `Bookmark.create` to return the correct data, wrapped in an instance:

```diff
   def self.create(options)
     if ENV['ENVIRONMENT'] == 'test'
       connection = PG.connect(dbname: 'bookmark_manager_test')
     else
       connection = PG.connect(dbname: 'bookmark_manager')
     end

-    connection.exec("INSERT INTO bookmarks (url) VALUES('#{options[:url]}')")
+    result = connection.exec("INSERT INTO bookmarks (url) VALUES('#{options[:url]}') RETURNING id, url")
+    Bookmark.new(result.first['id'], result.first['url'])
   end
```

Notice how we are `RETURNING` the ID and URL from the bookmark we just inserted into the database.

To get this working, we will need to update `Bookmark.new` to take two parameters:

```ruby
class Bookmark
  def initialize(id, url)
    @id  = id
    @url = url
  end

  ### rest of the class ###
end
```

We will also need to update `Bookmark.all` to wrap the returned data:

```ruby
   def self.all
     if ENV['ENVIRONMENT'] == 'test'
       connection = PG.connect(dbname: 'bookmark_manager_test')
     else
       connection = PG.connect(dbname: 'bookmark_manager')
     end

     result = connection.exec("SELECT * FROM bookmarks")
-    result.map { |link| link['url'] }
+    result.map { |bookmark| Bookmark.new(bookmark['id'], bookmark['url']) }
   end
```

And we'll need to expose the `id` and `url` data we just returned:

```ruby
class Bookmark
  attr_reader :id, :url

  def initialize(id, url)
    @id  = id
    @url = url
  end

  ### rest of the class ###
end
```

Congratulations! We've wrapped all incoming data from the database in program objects, and we can now update our view. However, our unit tests are still failing. This is because a test like this:

```ruby
describe '.create' do
  it 'creates a new bookmark' do
    bookmark = Bookmark.create(url: 'http://www.testbookmark.com')

    expect(Bookmark.all).to include bookmark
  end
end
```

Is making use of the Ruby equality operator, `==`, when checking whether a bookmark exists in a given collection of bookmarks.

### Overriding equality

Our database defines two rows as 'equal' if their IDs match. Let's duplicate this functionality in our program, test-first:

```ruby
# in spec/bookmark_spec.rb

describe '#==' do
  it 'two Bookmarks are equal if their IDs match' do
    bookmark_1 = Bookmark.new(1, url: 'http://testbookmark.com')
    bookmark_2 = Bookmark.new(1, url: 'http://testbookmark.com')

    expect(bookmark_1).to eq bookmark_2
  end
end
```

We can make this pass by overriding the build-in `==` method on `Bookmark`:

```ruby
# in lib/bookmark.rb

def ==(other)
  @id == other.id
end
```

Now our program will see two bookmarks as 'equal' if their IDs match. Nice!

[Next Challenge](../11_using_rake.md)
