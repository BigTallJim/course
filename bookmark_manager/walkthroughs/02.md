# Walkthrough - Setting up a Web Project

[Back to Challenge](../02_setting_up_a_web_project.md)

This walkthrough is provided as a handy checklist for setting up a web project. It's a good idea to learn this list by heart (or, at least, have it handy).

## The Ruby Web Project Setup List

### 1. Ready a project for Sinatra, RSpec, and Capybara

Any Ruby project starts by creating a Gemfile, which lists all libraries (dependent programs, or 'gems') of this project. [Bundler](http://bundler.io/), which is a dependency management program for Ruby, can do this for us. Use Bundler's `init` command:

```sh
$> bundle init
```

List the gems in the Gemfile:

```ruby
# in Gemfile
source 'https://rubygems.org'

gem 'sinatra'
gem 'rspec'
gem 'capybara'
```

We've listed dependencies as strings, but the actual programs aren't installed to the project yet. Bundler can look through a Gemfile, and install each gem listed there by executing the `gem` function with the provided string as an argument. Use Bundler's `install` command:

```sh
$> bundle install
```

### 2. Set up RSpec

```
.
├── spec
│   └── spec_helper.rb
└── .rspec
```

For `rspec` to work, we need two things:

-  a `spec` directory containing a `spec_helper.rb` file, which configures the test suite. The `spec_helper.rb` is automatically run every time you run `rspec`.
- a `.rspec` file, which configures the output of the `rspec` command itself. [`rspec` has modifier flags](https://relishapp.com/rspec/rspec-core/docs/command-line), like `--warnings`, which change the output of running `rspec` (but don't change the tests themselves).

Running RSpec with the `--init` flag will create these things for us:

```sh
$> rspec --init
```

### 3. Set up Sinatra and Rack

In the root directory, set up a basic Sinatra application in file called `app.rb`:

```ruby
# in app.rb

require 'sinatra/base'

class BookmarkManager < Sinatra::Base
  get '/' do
    'Hello World'
  end

  run! if app_file == $0
end
```

And configure the `rackup` command to run the application in `app.rb`, via a file called `config.ru`:

```ruby
# in config.ru

require_relative "./app"

run BookmarkManager
```

Your directory should now look like this:

```
.
└── bookmark_manager
    ├── spec
    │   ├── features
    │   └── spec_helper.rb
    ├── .rspec
    ├── Gemfile
    ├── Gemfile.lock
    ├── app.rb
    └── config.ru
```

### 4. Make Capybara talk to Sinatra

To configure Capybara, we need to adjust the `spec_helper.rb`, which configures our tests. Specifically, when we run `rspec` we need it to be configured in the following way:

- Set the environment to "test".
- Bring in the contents of the `app.rb` file.
- Require all the testing gems (RSpec, Capybara, and the Capybara/RSpec package that lets them talk to each other).
- Tell Capybara that any instructions like `visit('/')` should be directed at the application called 'BookmarkManager'.

Add the following to `spec/spec_helper.rb`:

```ruby
# in spec/spec_helper.rb

# Set the environment to "test"
ENV['RACK_ENV'] = 'test'

# Bring in the contents of the `app.rb` file
require File.join(File.dirname(__FILE__), '..', 'app.rb')

# Require all the testing gems
require 'capybara'
require 'capybara/rspec'
require 'rspec'

# Tell Capybara to talk to BookmarkManager
Capybara.app = BookmarkManager
```

> Obviously, you don't need to add the comments. But you should understand what each line does, so you can vary them later with more advanced packages and setup scenarios.

### 5. Profit!

You can now add feature tests to the `spec/features` directory, and run feature tests with `rspec features`.

> Running `rspec` will run both features and regular unit specs.

## Building the first feature

Now we have a complete app, let's add the following feature:

```
As a time-pressed user
So that I can quickly go to web sites I regularly visit
I would like to see a list of links on the homepage
```

Let's write a feature test for this. A reasonable first step is that a user can visit the homepage, and see a link:

```ruby
# in spec/features/see_list_of_links_spec.rb

feature 'Viewing links' do
  scenario 'A user can see links' do
    visit('/')

    expect(page).to have_content "http://www.makersacademy.com"
    expect(page).to have_content "http://www.google.com"
    expect(page).to have_content "http://www.facebook.com"
  end
end
```

We already built a controller – it's in `app.rb` – and it already has a `/` route:

```ruby
# in app.rb

require 'sinatra/base'

class BookmarkManager < Sinatra::Base
  get '/' do
    'Hello World'
  end

  run! if app_file == $0
end
```

Let's modify the `/` route to solve this failing test as simply as we can:

```ruby
get '/' do
  links = [
            "http://www.makersacademy.com",
            "http://www.google.com",
            "http://www.facebook.com"
           ]

  links.join
end
```

Now that we have a passing test, we can refactor. We're going to refactor **using MVC conventions**.

At the moment, our app isn't MVC: it's just C. We're setting up some data (`links`), acting on that data, and rendering that data as a string, all in the controller.

Arguably this should be split up in the following way:

```

| Component   | Responsibility                                | Refactor                            |
|------------ |---------------------------------------------  |------------------------------------ |
| Model       | Encapsulate logic with relevant data          | Encapsulate link data in a class    |
| View        | Display the result to a user                  | Show the link data in a list        |
| Controller  | Get data from the model and put in the view   | Render link data into to the view   |
```

First, let's make the controller–view interaction follow the MVC convention. That is: the controller combines data (the links) with the view (an erb template):

```ruby
get '/' do
  @links = [
            "http://www.makersacademy.com",
            "http://www.google.com",
            "http://www.facebook.com"
           ]

  erb :index
end
```

And let's write a view that handles the links:

```html
<!-- in views/index.erb -->

<ul>
  <% @links.each do |link| %>
    <li><%= link %></li>
  <% end %>
</ul>
```

Second, let's make the controller-model interaction follow the MVC convention. That is: the controller gets data (the links) from the model.

Let's remind ourselves of the sketched domain model:

```
╔════════════╗         .all         ╔════════════╗
║            ║--------------------->║            ║
║ Controller ║   [array of links]   ║    Link    ║
║            ║<---------------------║            ║
╚════════════╝                      ╚════════════╝
```

My first step when solving these sorts of tests is to imagine that my controller is a kind of Integration Test. That is, I can play around in it to figure out what sort of code I want. Do I want this:

```ruby
get '/' do
  @links = Link.all
  erb :index
end
```

Or this:

```ruby
get '/' do
  @links = Link.get(:all)
  erb :index
end
```

Or this:

```ruby
get '/' do
  @links = Link.to_a
  erb :index
end
```

Or some other thing?

I'll go with my original guess, and build a `Link` class that has a class method `.all`. Let's do it test-first, of course:

```ruby
# in spec/link_spec.rb

require 'link'

describe Link do
  describe '.all' do
    it 'returns all links' do
      links = Link.all

      expect(links).to include("http://www.makersacademy.com")
      expect(links).to include("http://www.google.com")
      expect(links).to include("http://www.facebook.com")
    end
  end
end
```

And here's a class that solves this failing test:

```ruby
# in lib/link.rb

class Link
  def self.all
    [
      "http://www.makersacademy.com",
      "http://www.google.com",
      "http://www.facebook.com"
     ]
  end
end
```

Now that we have this class, we can require it in `app.rb`, which becomes:

```ruby
# in app.rb

require 'sinatra/base'
require './lib/link'

class BookmarkManager < Sinatra::Base
  get '/' do
    @links = Link.all
    erb :index
  end

  run! if app_file == $0
end
```

That's the refactor over.

> One good sign that this is a sensible refactor is that the feature test for viewing links and the unit test for `Link` are very similar. When you think about it, they're doing similar things: presenting Link data to two different interfaces (feature test presents to the browser interface, unit test presents to the controller interface). This sort of simple similarity across the two interfaces feels 'right'.

### Summary

1. We wrote a failing test.
2. We solved the failing test with some easy code (an array in the controller).
3. We refactored to an MVC pattern, implementing a view and a model called `Link`.

As part of 3, we wrote a unit test for `Link`.

> We'll basically be repeating these three steps forever. The big takeaway here is: move in a small steps, write code that works, and refactor each time. The two biggest mistakes we see are when devs try to refactor too early (i.e. "I know what this design should look like, why should I write the easy stuff first?") and when devs fail to refactor at all (i.e. "I'll refactor this later when I have some more to work with."). Avoid both _premature refactoring_ and _refactoring later_: both lead to ruin.

[next challenge](../03_setting_up_a_database.md)
