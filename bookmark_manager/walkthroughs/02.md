# Walkthrough - Setting up a Web Project

[Back to Challenge](../02_setting_up_a_web_project.md)

Set up the app using the [:pill: Ruby Web Project Setup Checklist](../../pills/ruby_web_project_setup_list.md). It's a good idea to learn this list by heart (or, at least, have it handy).

We're going to follow a complete TDD cycle for this feature. That is:

1. Write a failing feature test.
2. Solve the feature test in the simplest possible way.
3. Use the Model-View-Controller (MVC) pattern to refactor our solution.

### 1. Failing Feature Test

Now we have a complete app, let's add the following feature:

```
As a time-pressed user
So that I can quickly go to web sites I regularly visit
I would like to see a list of links on the homepage
```

Let's write a feature test for this. A reasonable first step is that a user can visit the homepage, and see a link:

```ruby
# in spec/features/see_list_of_links_spec.rb

feature 'Viewing links' do
  scenario 'A user can see links' do
    visit('/')

    expect(page).to have_content "http://www.makersacademy.com"
    expect(page).to have_content "http://www.google.com"
    expect(page).to have_content "http://www.facebook.com"
  end
end
```

### 2. Passing in the simplest possible way

We already built a controller – it's in `app.rb` – and it already has a `/` route:

```ruby
# in app.rb

require 'sinatra/base'

class BookmarkManager < Sinatra::Base
  get '/' do
    'Hello World'
  end

  run! if app_file == $0
end
```

Let's modify the `/` route to solve this failing test as simply as we can:

```ruby
get '/' do
  links = [
            "http://www.makersacademy.com",
            "http://www.google.com",
            "http://www.facebook.com"
           ]

  links.join
end
```

Run the feature test using `rspec features` – it passes.

### 3. Refactoring to MVC

Now that we have a passing test, we can refactor. We're going to refactor **using MVC conventions**.

At the moment, our app isn't MVC: it's just C. We're setting up some data (`links`), acting on that data, and rendering that data as a string, all in the controller.

Arguably this should be split up in the following way:

```

| Component   | Responsibility                                | Refactor                            |
|------------ |---------------------------------------------  |------------------------------------ |
| Model       | Encapsulate logic with relevant data          | Encapsulate link data in a class    |
| View        | Display the result to a user                  | Show the link data in a list        |
| Controller  | Get data from the model and put in the view   | Render link data into to the view   |
```

First, let's make the controller–view interaction follow the MVC convention. That is: the controller combines data (the links) with the view (an erb template):

```ruby
get '/' do
  @links = [
            "http://www.makersacademy.com",
            "http://www.google.com",
            "http://www.facebook.com"
           ]

  erb :index
end
```

And let's write a view that handles the links:

```html
<!-- in views/index.erb -->

<ul>
  <% @links.each do |link| %>
    <li><%= link %></li>
  <% end %>
</ul>
```

Second, let's make the controller-model interaction follow the MVC convention. That is: the controller gets data (the links) from the model.

Let's remind ourselves of the sketched domain model:

```
╔════════════╗         .all         ╔════════════╗
║            ║--------------------->║            ║
║ Controller ║   [array of links]   ║    Link    ║
║            ║<---------------------║            ║
╚════════════╝                      ╚════════════╝
```

My first step when solving these sorts of tests is to imagine that my controller is a kind of Integration Test. That is, I can play around in it to figure out what sort of code I want. Do I want this:

```ruby
get '/' do
  @links = Link.all
  erb :index
end
```

Or this:

```ruby
get '/' do
  @links = Link.get(:all)
  erb :index
end
```

Or this:

```ruby
get '/' do
  @links = Link.to_a
  erb :index
end
```

Or some other thing?

I'll go with my original guess, and build a `Link` class that has a class method `.all`. Let's do it test-first, of course:

```ruby
# in spec/link_spec.rb

require 'link'

describe Link do
  describe '.all' do
    it 'returns all links' do
      links = Link.all

      expect(links).to include("http://www.makersacademy.com")
      expect(links).to include("http://www.google.com")
      expect(links).to include("http://www.facebook.com")
    end
  end
end
```

And here's a class that solves this failing test:

```ruby
# in lib/link.rb

class Link
  def self.all
    [
      "http://www.makersacademy.com",
      "http://www.google.com",
      "http://www.facebook.com"
     ]
  end
end
```

Now that we have this class, we can require it in `app.rb`, which becomes:

```ruby
# in app.rb

require 'sinatra/base'
require './lib/link'

class BookmarkManager < Sinatra::Base
  get '/' do
    @links = Link.all
    erb :index
  end

  run! if app_file == $0
end
```

That's the refactor over. [Here's](https://github.com/sjmog/bookmark_manager/commit/5d6b8da046dbf533e5e92b49275951ad2d22d684) a commit of this stage.

> One good sign that this is a sensible refactor is that the feature test for viewing links and the unit test for `Link` are very similar. When you think about it, they're doing similar things: presenting Link data to two different interfaces (feature test presents to the browser interface, unit test presents to the controller interface). This sort of simple similarity across the two interfaces feels 'right'.

## Summary

1. We wrote a failing test.
2. We solved the failing test with some easy code (an array in the controller).
3. We refactored to an MVC pattern, implementing a view and a model called `Link`.

As part of 3, we wrote a unit test for `Link`.

> We'll basically be repeating these three steps forever. The big takeaway here is: move in a small steps, write code that works, and refactor each time. The two biggest mistakes we see are when devs try to refactor too early (i.e. "I know what this design should look like, why should I write the easy stuff first?") and when devs fail to refactor at all (i.e. "I'll refactor this later when I have some more to work with."). Avoid both _premature refactoring_ and _refactoring later_: both lead to ruin.

[Next Challenge](../03_setting_up_a_database.md)
