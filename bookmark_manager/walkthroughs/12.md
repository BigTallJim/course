# Walkthrough – REST and Resources

[Back to the Challenge](../12_one_to_many_relationships.md)

In a one-to-many relationship, there are two models:

- one 'parent' model, `Bookmark`, _has many_ `Comment`s.
- the 'child' model, `Comment`, _belongs to_ a single `Bookmark`.

```
  ONE       ––≡≡   MANY
 Bookmark   ––≡≡  Comments
```

The only way to store this in a table relationship is to add an extra column to the 'child' model.

For instance, in the table below, the first two comments refer to a Bookmark with an ID of 1. The last comment refers to a Bookmark with an ID of 2:

```
| id | text                       | bookmark_id |
|----|----------------------------|-------------|
| 1  | Great Bookmark!            | 1           |
| 2  | I don't like this Bookmark | 1           |
| 3  | What a cool resource       | 2           |
```

Comments with ID 1 and 2 are comments on the same Bookmark. If they were displayed, they'd look like this:

- Bookmark 1
  - Great Bookmark!
  - I don't like this Bookmark.
- Bookmark 2
  - What a cool resource

## 1. Implementing Comments

[Here](https://github.com/sjmog/bookmark_manager/commit/f610b7e3bf77073fc615c04de178a13ce811063c) is a commit for setting up this relationship. It's OK if your approach differs – so long as you're setting up the one-to-many table relationship correctly.

Particularly interesting are:

- The RESTful routing structure, `Bookmarks/:id/comments`.
- A script to _teardown_ databases, as well as set them up.
- How `Comment.create` also wraps the data returned from the database, using the SQL command `RETURNING`, and how this makes testing `.create` much easier.

## 2. Making `Bookmark`'s interface more similar to `Comment`'s

When we build programs, we'll often find ourselves creating objects that do similar things. For instance: both `Bookmark` and `Comment` are reading and writing information to the database.

When we see that objects are doing similar things (using similarly-named methods, too), it's worthwhile to try and homogenise how they do those things. This can lead to exciting opportunities for extracting classes later on.

In [this commit](https://github.com/sjmog/bookmark_manager/commit/7c80d5542fed90c471ccd50a232afb818ead9260), I used the inspiration from `Comment.create`, which we wrap in a `Comment.new` object, to test `Bookmark.create`.

## 3. Removing the test dependency on setup data

It feels bad that we have a bunch of setup data sitting around in the database. But, our feature and unit tests are dependent on it. We can remove this dependency:

- By setting up each test's data in the test itself, and
- By removing the test data from the setup script.

A commit doing these things is [here](https://github.com/sjmog/bookmark_manager/commit/c81305935bf16747f16bb20466d4c75d5e1d667d).

My first step is to move calls to `Bookmark.create` in `Bookmark_spec.rb` into a `before(:each)` block. This sets up the required Bookmark before each test. That is:

```ruby
# in spec/Bookmark_spec.rb

before(:each) do
  @Bookmark = Bookmark.create(url: 'http://www.testBookmark.com', title: 'Test Bookmark')
end
```

My second step is to remove the dummy data from the database, and use the newly-wrapped `Bookmark` data dynamically in the tests. Here's an example:

```ruby
feature 'Deleting a Bookmark' do
  scenario 'A user can delete a Bookmark' do
    Bookmark = Bookmark.create(url: 'http://testexample.com', title: 'Test Bookmark')
    visit('/bookmarks')

    # Now the deletion is dynamic
    within "#Bookmark-#{Bookmark.id}" do
      click_button 'Delete'
    end

    expect(current_path).to eq '/bookmarks'
    expect(page).not_to have_content 'Makers Academy'
  end
end
```

[Next Challenge](../13_many_to_many_relationships.md)
