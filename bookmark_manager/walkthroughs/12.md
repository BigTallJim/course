## Walkthrough – CRUD

[Back to Challenge](../12_crud.md)

**CRUD** is an acronym for the four 'basic functions' of persistent storage:

- **Creating** data
- **Reading** data
- **Updating** data
- **Deleting** data

So far, our application is a CR app. Let's make it a CRUD one.

This walkthrough is in two parts:

- Deleting Bookmarks.
- Updating Bookmarks.

## 1. Deleting Bookmarks

Here's our requirement:

* Delete Bookmarks

Here's a User Story for that requirement:

```
As a user
So I can remove my bookmark from Bookmark Manager
I want to delete a bookmark
```

Here's the user flow for deleting a bookmark:

1. Visit the homepage.
2. Click a 'delete' button next to a bookmark.
3. See the homepage, without that bookmark.

Here's that flow in Capybara terms:

```ruby
# in spec/features/deleting_a_bookmark_spec.rb

feature 'Deleting a bookmark' do
  scenario 'A user can delete a bookmark' do
    Bookmark.create(url: 'http://makersacademy.com', title: 'Makers Academy')
    visit('/bookmarks')

    within '#bookmark-1' do
      click_button 'Delete'
    end

    expect(current_path).to eq '/bookmarks'
    expect(page).not_to have_content 'Makers Academy'
  end
end
```

> I've used Capybara's `within` method to click the Delete button inside the element with ID 'bookmark-1'. Take a look at the index.erb [here](https://github.com/sjmog/bookmark_manager/blob/de7b8d6a93d0edc7bed45ee9e166e57a2f16d674/views/index.erb) for how I've labelled that element.

When we run this test, it fails as expected: I haven't added the button to `index.erb` yet. Let's do that now:

```diff
<ul>
  <% @bookmarks.each do |bookmark| %>
    <li id="bookmark-<%= bookmark.id %>">
      <a href="<%= bookmark.url %>" target="_blank">
        <%= bookmark.title %>
      </a>
+      <input type="submit" value="Delete" />
    </li>
  <% end %>
</ul>
```

Our test still fails, because this button doesn't do anything. Let's wrap it in a form:

```diff
<ul>
  <% @bookmarks.each do |bookmark| %>
    <li id="bookmark-<%= bookmark.id %>">
      <a href="<%= bookmark.url %>" target="_blank">
        <%= bookmark.title %>
      </a>
+      <form action="/bookmarks/<%= bookmark.id %>" method="post">
+        <input type='hidden' name='_method' value='DELETE'/>
         <input type="submit" value="Delete" />
+      </form>
    </li>
  <% end %>
</ul>
```

> We had to do something a bit 'hacky' to delete a record whilst maintaining RESTfulness.  Read more [here](https://softwareengineering.stackexchange.com/questions/114156/why-are-there-are-no-put-and-delete-methods-on-html-forms).

Now our form submits! But 'Sinatra doesn't know this ditty'.

We need to build a route for our Delete button to submit to, in `app.rb`:

```ruby
# in app.rb

delete '/bookmarks/:id/delete' do
  # let's print out the form params
  p params
end
```

What do we do in this route? We'd like something like `Bookmark.delete` to happen – but how will we know which bookmark to delete? We need some way for our form to tell us which 'Delete' button was clicked. Notice that, when we run our test at the moment, the `params` are empty.

Let's use a **hidden input** to submit the bookmark ID along with the POST request:

```diff
<ul>
  <% @bookmarks.each do |bookmark| %>
    <li id="bookmark-<%= bookmark.id %>">
      <a href="<%= bookmark.url %>" target="_blank">
        <%= bookmark.title %>
      </a>
      <form action="/bookmarks/<%= bookmark.id >" method="post">
        <input type='hidden' name='_method' value='DELETE'/>
+       <input type="hidden" name="id" value="<%= bookmark.id %>">
        <input type="submit" value="Delete" />
      </form>
    </li>
  <% end %>
</ul>
```

Now when we submit the form, `params` equals `{"id"=>"1"}`. We can use this to write the SQL to delete the bookmark with that ID, and redirect:

```ruby
# in app.rb

delete '/bookmarks/:id/delete' do
  connection = PG.connect(dbname: 'bookmark_manager_test')
  connection.exec("DELETE FROM bookmarks WHERE id = #{params['id']}")
  redirect '/'
end
```

Now that our test passes, let's move the SQL into the `Bookmark` model. Start with a spec for `Bookmark.delete`:

```ruby
# in spec/bookmark_spec.rb

describe '.delete' do
  it 'deletes a bookmark' do
    Bookmark.create("http://www.makersacademy.com")
    Bookmark.delete(1)

    bookmarks = Bookmark.all
    urls = bookmarks.map(&:url)

    expect(urls).not_to include "http://www.makersacademy.com"
  end
end
```

And let's pass this test by moving the logic from the controller to the model:

```ruby
# in lib/bookmark.rb

class Bookmark
  def self.delete(id)
    connection.exec("DELETE FROM bookmarks WHERE id = #{id}")
  end

  ### rest of the class ###
end
```

Our unit test passes, so we can rewrite the controller action:

```ruby
# in app.rb

delete '/bookmarks/:id/delete' do
  Bookmark.delete(params['id'])
  redirect '/'
end
```

All tests pass: we've delivered the feature!

## Update Bookmarks

As always, our flow is:

- Requirement
- User Story
- Feature Test
- Unit Tests
- Implementation
- Refactoring

> Prefer to read the code directly? You can check out the entire commit [here](https://github.com/sjmog/bookmark_manager/commit/5d60ae2f03d30c86060833166e51453ebf9aabf7).

Here's our requirement:

* Update Bookmarks

Here's a User Story for that requirement:

```
As a user
So I can change a bookmark in Bookmark Manager
I want to update a bookmark
```

Here's the user flow for deleting a bookmark:

1. Visit the 'update bookmark' form for a particular bookmark.
2. Fill in the form with new data – say, a new title – and submit it.
3. See the homepage, with the updated bookmark title (and the old one is gone).

Here's that flow in Capybara terms:

```ruby
# in spec/features/updating_a_bookmark_spec.rb

feature 'Updating a bookmark' do
  scenario 'A user can update a bookmark' do
    visit('/bookmarks/1/edit')

    fill_in('url', with: "http://www.snakersacademy.com")
    fill_in('title', with: "Snakers Academy")
    click_button('Submit')

    expect(current_path).to eq '/bookmarks'
    expect(page).not_to have_content 'Makers Academy'
    expect(page).to have_content 'Snakers Academy'
  end
end
```

> I've decided to make use of Sinatra's [named parameters](http://sinatrarb.com/intro.html) for this route: so visiting `/bookmarks/1/edit` will allow the user to update a bookmark with an ID of 1, and so on.

Let's define a route for this form:

```ruby
# in app.rb

get '/bookmarks/:id/edit' do
  erb :"bookmarks/edit"
end
```

And a view with the form:

```html
<!-- in views/update_a_bookmark.erb -->

<form action="/bookmarks/<%= bookmark.id %>" method="post">
  <input type="text" name="url" />
  <input type="text" name="title" />
  <input type="hidden" name="_method" value="patch">
  <input type="submit" value="Submit" />
</form>
```

And another route, to which this form submits:

```ruby
patch '/bookmarks/:id' do
  p params
  redirect('/bookmarks')
end
```

Our test now fails because, although we have all the right routes and views, we're not doing anything to the database in any of them:

```
Failures:

  1) Updating a bookmark A user can update a bookmark
     Failure/Error: expect(page).not_to have_content 'Makers Academy'
       expected not to find text "Makers Academy" in "Makers Academy Google Facebook"
```

Working backwards, we'd like our `PATCH /bookmarks/:id` route to do actually update a bookmark. To update a bookmark, we need the ID of the bookmark we're trying to update. To get that, we need the bookmark ID to be submitted by the form. To do that, we need to add a hidden field to the form containing the bookmark ID (like we did with delete). And to do _that_, we need to supply the bookmark ID to the form.

Let's update our `GET /bookmarks/:id` route with the bookmark ID:

```diff
# in app.rb

get '/bookmarks/:id' do
+  @bookmark_id = params['id']
  erb :"bookmarks/edit"
end
```

Let's update the form to take that Bookmark ID in a hidden input:

```diff
<!-- in views/bookmarks/edit.erb -->

<form action="/bookmarks/<%= @bookmark.id %>" method="post">
+  <input type="hidden" name="id" value="<%= @bookmark_id %>">
  <input type="text" name="url" />
  <input type="text" name="title" />
  <input type="hidden" name="_method" value="patch">
  <input type="submit" value="Submit" />
</form>
```

And update the `PATCH /bookmarks/:id` route with the SQL required to connect to the database, and update the appropriate record:

```ruby
# in app.rb

patch '/bookmarks/:id' do
  connection = PG.connect(dbname: 'bookmark_manager_test')
  connection.exec("UPDATE bookmarks SET url = '#{params['url']}', title = '#{params['title']}' WHERE id = '#{params['id']}'")

  redirect('/')
end
```

Our test now passes. Time to refactor!

The first obvious refactor is to push the updating SQL into the model, spec-first:

```ruby
# in spec/bookmark_spec.rb

describe '.update' do
  it 'updates a bookmark' do
    Bookmark.create(url: 'http://www.makersacademy.com')
    Bookmark.update(1, url: 'http://www.snakersacademy.com', title: 'Snakers Academy')

    bookmarks = Bookmark.all
    urls = bookmarks.map(&:url)
    titles = bookmarks.map(&:title)

    expect(urls).not_to include "http://www.makersacademy.com"
    expect(titles).not_to include "Makers Academy"
    expect(urls).to include "http://www.snakersacademy.com"
    expect(titles).to include "Snakers Academy"
  end
end
```

We can solve this by moving the controller SQL into the bookmark model:

```ruby
# in lib/bookmarks.rb

def self.update(id, options)
  DatabaseConnection.query("UPDATE bookmarks SET url = '#{options[:url]}', title = '#{options[:title]}' WHERE id = '#{id}'")
end
```

And replacing the controller SQL with the call to the Bookmark model:

```ruby
# in app.rb

patch '/bookmarks/:id' do
  Bookmark.update(params['id'], params)
  redirect('/')
end
```

Secondly: **wouldn't it be nice** if our 'edit' form contained the data-to-be-edited? That is: when a user visits the 'edit' form, they see the data 'as it is', and can edit it.

To do this, we need to pass more than just `@bookmark_id` to the form. We need to pass a `Bookmark` object that wraps the data for that bookmark. We've got `Bookmark.all` to pull all bookmarks from the database: we need some way of pulling one Bookmark out. Here's how it could work in the controller:

```ruby
# in app.rb

get '/bookmarks/:id/edit' do
  @bookmark = Bookmark.find(params['id'])
  erb :"bookmarks/edit"
end
```

Let's write a `Bookmark.find` method to do that.

```ruby
# in spec/bookmark_spec.rb

describe '.find' do
  it 'finds a bookmark' do
    bookmark = Bookmark.find(1)

    expect(bookmark.url).to eq "http://www.makersacademy.com"
    expect(bookmark.title).to eq "Makers Academy"
  end
end
```

Here's the implementation in `Bookmark`:

```ruby
# in lib/bookmark.rb

class Bookmark
  def self.find(id)
    result = DatabaseConnection.query("SELECT * FROM bookmarks WHERE id = #{id}")
    result.map { |bookmark| Bookmark.new(bookmark['id'], bookmark['url'], bookmark['title']) }.first
  end

  ### rest of the class ###
end
```

> Just like with `Bookmark.all`, we have to use the ORM pattern to wrap the bookmark data in a useful Ruby object.

Now we can use this `Bookmark` object in our form. We can set the `value` attribute of each input to the current value of the `bookmark`:

```html
<!-- in views/update-a-bookmark.erb -->

<form action="/bookmarks/<%= @bookmark.id %>" method="post">
  <input type="hidden" name="id" value="<%= @bookmark.id %>">
  <input type="text" name="url" value="<%= @bookmark.url %>" />
  <input type="text" name="title" value="<%= @bookmark.title %>" />
  <input type="hidden" name="_method" value="patch">
  <input type="submit" value="Submit" />
</form>
```

Now when a user visits the form, this is what they see:

![A form pre-filled with the current bookmark data](../images/form-with-values.png)

Now, when a user updates a bookmark, it feels much more like they're 'editing the data' for that bookmark.

[Next Challenge](../13_one_to_many_relations.md)
