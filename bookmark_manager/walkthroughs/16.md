# Walkthrough – REST and Resources

[Back to the Challenge](../16_one_to_many_relationships.md)

In a one-to-many relationship, there are two models:

- one 'parent' model, `Link`, _has many_ `Comment`s.
- the 'child' model, `Comment`, _belongs to_ a single `Link`.

```
  ONE   ––≡≡   MANY
 Link   ––≡≡  Comments
```

The only way to store this in a table relationship is to add an extra column to the 'child' model.

For instance, in the table below, the first two comments refer to a link with an ID of 1. The last comment refers to a link with an ID of 2:

```
| id | text                    | link_id |
|----|-------------------------|---------|
| 1  | Great link!             | 1       |
| 2  | I don't like this link. | 1       |
| 3  | What a cool resource    | 2       |
```

Comments with ID 1 and 2 are comments on the same link. If they were displayed, they'd look like this:

- Link 1
  - Great link!
  - I don't like this link.
- Link 2
  - What a cool resource

## 1. Implementing Comments

[Here](https://github.com/sjmog/bookmark_manager/commit/f610b7e3bf77073fc615c04de178a13ce811063c) is a commit for setting up this relationship. It's OK if your approach differs – so long as you're setting up the one-to-many table relationship correctly.

Particularly interesting are:

- The RESTful routing structure, `links/:id/comments`.
- A script to _teardown_ databases, as well as set them up.
- How `Comment.create` also wraps the data returned from the database, using the SQL command `RETURNING`, and how this makes testing `.create` much easier.

## 2. Making `Link`'s interface more similar to `Comment`'s

When we build programs, we'll often find ourselves creating objects that do similar things. For instance: both `Link` and `Comment` are reading and writing information to the database.

When we see that objects are doing similar things (using similarly-named methods, too), it's worthwhile to try and homogenise how they do those things. This can lead to exciting opportunities for extracting classes later on.

In [this commit](https://github.com/sjmog/bookmark_manager/commit/7c80d5542fed90c471ccd50a232afb818ead9260), I used the inspiration from `Comment.create`, which we wrap in a `Comment.new` object, to test `Link.create`. 

## 3. Removing the test dependency on setup data

It feels bad that we have a bunch of setup data sitting around in the database. But, our feature and unit tests are dependent on it. We can remove this dependency:

- By setting up each test's data in the test itself, and
- By removing the test data from the setup script.

A commit doing these things is [here](https://github.com/sjmog/bookmark_manager/commit/c81305935bf16747f16bb20466d4c75d5e1d667d).

My first step is to move calls to `Link.create` in `link_spec.rb` into a `before(:each)` block. This sets up the required link before each test. That is:

```ruby
# in spec/link_spec.rb

before(:each) do
  @link = Link.create(url: 'http://www.testlink.com', title: 'Test Link')
end
```

My second step is to remove the dummy data from the database, and use the newly-wrapped `Link` data dynamically in the tests. Here's an example:

```ruby
feature 'Deleting a link' do
  scenario 'A user can delete a link' do
    link = Link.create(url: 'http://testexample.com', title: 'Test Link')
    visit('/links')

    # Now the deletion is dynamic
    within "#link-#{link.id}" do
      click_button 'Delete'
    end

    expect(current_path).to eq '/links'
    expect(page).not_to have_content 'Makers Academy'
  end
end
```

[Next Challenge](../17_many_to_many_relationships.md)
