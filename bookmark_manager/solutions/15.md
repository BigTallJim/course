# Solution

[Back to Challenge](../15_tagging_links.md)


First we need a failing feature test

```ruby
#/spec/features/adding_tags_spec.rb
feature 'Adding tags' do

  scenario 'I can add a single tag to a new link' do
    visit '/links/new'
    fill_in 'url',   with: 'http://www.makersacademy.com/'
    fill_in 'title', with: 'Makers Academy'

    fill_in 'tag',  with: 'education' # for now, let's input a single tag value.
    #later on we can go for multiple tags.

    click_button 'Create link'
    link = Link.first
    expect(link.tags.map(&:name)).to include('education')
  end

end
```

You should get a Capybara error: cannot find field "tag", so update the new link form:

```html
<h1> New Link </h1>

<form action='/links' method='POST'>
  <label for='title'>
    Title:
    <input type='text' name='title' />
  </label>
  <label for='url'>
    URL:
    <input type='text' name='url' />
  </label>
  <label for='tag'>
    Tag:
    <input type='text' name='tag' />
  </label>
  <input type='submit' value='Create link'>

</form>
```

Gives us a model related error:

```
1) Adding tags I can add a single tag to a new link
     Failure/Error: expect(link.tags).to include("education")
     NoMethodError:
       undefined method 'tags' for #<Link:0x007fe22c3a95b0>
     # ./spec/features/adding_links_spec.rb:19:in 'block (2 levels) in <top (required)>'
```

So, the test tells us that the method "tags" is undefined. But what do we want our tags method to be? Ideally, it would be some clever method that allows us to access all the tags associated with this link automatically. Well, with DataMapper, that's exactly what we can do by defining a relationship. In this case, it's a many-to-many relationship (why?), which we can model like this in link.rb:

```ruby
class Link
  include DataMapper::Resource

  has n, :tags, through: Resource

  property :id, Serial
  property :title, String
  property :url, String
end
```

Now we get another error:

```
Cannot find the child_model Tag for Link in tags (NameError)
```

The error occurs because we have not defined the associated Tag model, which the Link model now expects to exist.

Before adding the Tag model, let us review the process we are going through.

1. We have written a test that describes the functionality we want to see.
2. We then ran the test and it highlighted a problem - no tags associated to a link. We then fixed that problem specifically. As we did not create the Tag class straight away, we ran the test again and it told us that we did not have the Tag model. We then know we need to create a Tag model to overcome the error.

TDD involves repeating this process several times over, taking baby-steps forward each time.

The Tag model should be placed in `app/models/tag.rb` and look like this:

```ruby
class Tag
  include DataMapper::Resource

  property :id, Serial
  property :name, String
end
```

This is a great time to refactor our datamapper setup out of the link.rb file.  Let's create `app/data_mapper_setup.rb`:

```ruby
require 'data_mapper'
require 'dm-postgres-adapter'

require_relative 'models/tag'
require_relative 'models/link'

DataMapper.setup(:default, ENV['DATABASE_URL'] ||
 "postgres://localhost/bookmark_manager_#{ENV['RACK_ENV']}")
DataMapper.finalize
DataMapper.auto_migrate!
```

Don't forget to ensure you've removed the previous references from the Link class and now require `data_mapper_setup` in your `app.rb`:

```ruby
ENV['RACK_ENV'] ||= 'development'

require 'sinatra/base'
require_relative 'data_mapper_setup'

class BookmarkManager < Sinatra::Base
```

This should lead us to this next error:

```
Failure/Error: expect(link.tags.map(&:name)).to include('education')
       expected [] to include "education"
```

Though we might think [] denotes an array, what we see here is just the string representation of an object. It may be an Array - it may be any other type of object whose string representation is []. In this case, it is actually a DataMapper collection (which is much like an array). We're in a similar situation to before: we're POST'ing a value from an input field, namely 'tag', but nothing is happening with that data. Let's update the relevant route:

```ruby
post '/links' do
  link = Link.new(url: params[:url],     # 1. Create a link
                title: params[:title])
  tag  = Tag.create(name: params[:tag])  # 2. Create a tag for the link
  link.tags << tag                       # 3. Adding the tag to the link's DataMapper collection.
  link.save                              # 4. Saving the link.
  redirect to('/links')
end
```

You might want to spend some time understanding exactly what's going on in this action. There are some common patterns presented here.

You should also have all tests passing now.

However, on reflection, we may be mixing up our tests a little. We began by setting up the UI, then finished by testing the models. It can be difficult sometimes to separate the responsibilities of tests and you may find yourself writing tests like this one to drive the code you want to write. This is often an indication that we are missing a test layer. As you become more experienced, you will learn when to introduce new testing layers. For now, just think of this as a conversation point and discuss with you pair partner how you might have written different tests.

[next challenge](../16_filtering_tags.md)
