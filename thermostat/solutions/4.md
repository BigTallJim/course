# Solution - Airport Challenge in JavaScript

[Back to the Challenge](../4_airport_challange_js.md)

### Step 1

At this point you should be comfortable with setting up Jasmine, so we'll dive straight in to the code.

The first place I prefer to start with this kata is the plane, seeing as it's very simple in its logic and complexity.

We're going to use **strict mode**, which you can read up on here: [MDN - Strict Mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode). To invoke strict mode, place this at the top of your file:

```javascript
"use strict";
```

First we want to give the user the ability to create a plane object by running `new Plane();`. Let's set up our test file (and jump right in to writing our first test while we're at it):

```javascript
describe("Plane", function() {
  var plane;

  beforeEach(function() {
    plane = new Plane();
  });

  it("is in-flight when created (for some bizarre reason)", function() {
    expect(plane.isAirborne).toEqual(true);
  });
});
```

**NOTE** there is premature optimisation in this test file to speed up the pace of the tutorial since you will have been through these set up steps previously in the week.

Now we need to declare a `function` - specifically an `Object()` *constructor function* so that we can use the `new` keyword to **construct an object.**

```javascript
function Plane() {}
```

Now we need our first test to pass. In an effort to be the first aircraft manufacturer to create a plane whilst it's in the air, we need to make sure that every new `plane` object has a property that reflects the `airborne` status as being `true` from the start:

```javascript
function Plane() {
  this.isAirborne = true;
}
```

So here we should notice two things:
1. Our `isAirborne` property is situated between the `{}` of our `Plane` object constructor function.
2. The `this` keyword is employed.

In regards to #1, it's enough right now to be aware that this is where we store the property of an object. However, #2 is going to involve a [little bit of research on your part](http://javascriptissexy.com/understand-javascripts-this-with-clarity-and-master-it/). As a quick summary though, `this` tells the JavaScript interpreter that `isAirborne` belongs to `Plane`.

Great! Now we're defying gravity, let's find a way to bring this bird to the ground. Write a test for a `land` method:

```javascript
it("can land", function() {
  plane.land();
  expect(plane.isAirborne).toEqual(false);
});
```

Note in our test, when referring to `land` we place parenthesis at the end. Why? This is to communicate to the JavaScript interpreter that we want it to execute this function, as opposed to returning the contents.

And now to create our method. As you will have noticed, we place the _properties_ of an object "inside" that object. However, when we are writing methods that relate to the same object, we use a different technique:

### The `prototype` keyword

It's important to understand that unlike Ruby where your instances inherit from a class, when it comes to JavaScript, your instances inherit from other instances. When the JavaScript interpreter cannot find a property or method defined on the current instance it looks to the next instance in the inheritance chain for the missing information.

For more information on how prototypal inheritance works, check out this great article on [webreference.com](http://www.webreference.com/programming/javascript/prototypal_inheritance/index.html).

But for now, we can think of `prototype` as a "storage area" which relates to the object referenced immediately before the `prototype` keyword and stores the function (method) you are defining. Let's look at some code to understand this more thoroughly:

```javascript
Plane.prototype.land = function() {};
```

In this example, `prototype` binds `land` to `Plane`, so that you can make an instance of `Plane` which has the method `land()` available to it. Now, we want `land()` to change the flying status of the plane, and we achieve this using the following:

```javascript
Plane.prototype.land = function() {
  this.isAirborne = false;
};
```

Now is a fantastic opportunity to take stock of what we have learned here. Firstly, we have created a `Plane` **object constructor**, and given it a **property** of `isAirborne` (the 'is' part tells the next JavaScript Developer that this method should return a boolean value), and then we used the `prototype` keyword to *associate* or *bind* the `land` function to our `Plane`. Easy huh!

Now we've grounded our plane, it's time to let that bird soar once more! Since we can follow the pattern we just set down for `land()` (as we just want to create a method that resets `isAirborne` to true), the hardest challenge we face now is coming up with a decent name for our method. I'm going to pull rank and say it's called `takeOff`. Now let's write a test:

```javascript
it("can take off", function() {
  plane.land();
  plane.takeOff();
  expect(plane.isAirborne).toEqual(true);
});
```

And our method is not far behind...

```javascript
Plane.prototype.takeOff = function() {
  this.isAirborne = true;
};
```

Sweet success! We now have a fully-operational aircraft.

### Step 2

Now would be an excellent time to implement an ai


[Forward to the Challenge Map](../0_challenge_map.md)
